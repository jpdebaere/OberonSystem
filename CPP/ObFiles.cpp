// Generated by OberonViewer 0.7.5 on 2020-01-27T01:00:45
// Then further developed manually by RK
#include "ObFiles.h"
#include <QDir>
#include <QFileInfo>
#include <memory>
using namespace Ob;

static owned_ptr<Files> s_inst;


Files* Files::_inst()
{
	if( s_inst.get() == 0 )
		s_inst.reset( new Files() );
	return s_inst.get();
}

Files::File Files::Old(_ValArray<char> name)
{
    if( *name.data() == 0 )
        return 0;
    QDir dir(d_fileSystemPath);
    QFile f( dir.absoluteFilePath(name.data()) );
    if( f.exists() )
    {
        f.open(QIODevice::ReadOnly);
        FileDesc* res = new FileDesc();
        res->d_name = name.data();
        res->d_data = f.readAll();
        return res;
    }else
        return 0;
}

Files::File Files::New(_ValArray<char> name)
{
    FileDesc* res = new FileDesc();
    res->d_name = name.data();
    return res;
}

void Files::Register(File f)
{
    QDir dir(d_fileSystemPath);
    QFile out( dir.absoluteFilePath(f->d_name.data()) );
    out.open(QIODevice::WriteOnly);
    out.write(f->d_data);
}

void Files::Delete(_ValArray<char> name, int& res)
{
    QDir dir(d_fileSystemPath);
    dir.remove(name.data());
    res = 0;
}

void Files::Rename(_ValArray<char> old, _ValArray<char> new_, int& res)
{
    QDir dir(d_fileSystemPath);
    if( !QFileInfo(dir.absoluteFilePath(old.data())).exists() )
    {
        res = 2;
        return;
    }
    QFileInfo info(dir.absoluteFilePath(new_.data()));
    if( info.exists() )
    {
        dir.remove(new_.data());
        res = 1;
        if( !dir.rename(old.data(),new_.data()) )
            res = 3;
    }else
    {
        res = 0;
        if( !dir.rename(old.data(),new_.data()) )
            res = 3;
    }
}

int Files::Length(File f)
{
    return f->d_data.size();
}

void Files::Set(Rider& r, File f, int pos)
{
    r.eof = false;
    r.res = 0;
    if( f == 0 )
    {
        r.d_buf.close();
        r.d_file = 0;
        return;
    }
    if( !r.d_buf.isOpen() )
    {
        r.d_buf.setBuffer( &f->d_data );
        r.d_buf.open( QIODevice::ReadWrite );
    }
    if( pos < 0 )
        pos = 0;
    r.d_buf.seek(pos);
    r.d_file = f;
}

int Files::Pos(Rider& r)
{
    return r.d_buf.pos();
}

Files::File Files::Base(Rider& r)
{
    return r.d_file;
}

void Files::ReadByte(Rider& r, uint8_t& x)
{
    r.eof = false;
    r.res = 0;
    if( r.d_buf.atEnd() || !r.d_buf.isOpen() )
    {
        r.eof = true;
        x = 0;
        return;
    }
    if( !r.d_buf.getChar( (char*)&x ) )
        r.res = 1; // num of bytes not read
}

void Files::Read(Rider& r, char& ch)
{
    ReadByte(r, (uint8_t&)ch );
}

void Files::ReadInt(Rider& R, int& x)
{
    uint8_t x0, x1, x2, x3;
    ReadByte(R, x0); ReadByte(R, x1); ReadByte(R, x2); ReadByte(R, x3);
    x = ((x3 * 0x100 + x2) * 0x100 + x1) * 0x100 + x0;
}

void Files::ReadString(Rider& R, _VarArray<char> x)
{
    int i = 0;
    char ch;
    Read(R, ch);
    while( ch != 0 )
    {
      if( i < x.size()-1 )
      {
          x[i] = ch; i++;
      }
      Read(R, ch);
    }
    x[i] = 0;
}

void Files::WriteByte(Rider& r, uint8_t x)
{
    if( !r.d_buf.putChar((char)x) )
        r.res = 1;
    else
        r.res = 0;
}

void Files::Write(Rider& r, char ch)
{
    WriteByte(r,(uint8_t)ch);
}

void Files::WriteInt(Rider& R, int x)
{
    Files* _this = _inst();
    _this->WriteByte(R, MOD(x,0x100));
    _this->WriteByte(R, MOD(DIV(x,0x100),0x100));
    _this->WriteByte(R, MOD(DIV(x,0x10000),0x100));
    _this->WriteByte(R, MOD(DIV(x,0x1000000),0x100));
}

void Files::WriteString(Rider& R, _ValArray<char> x)
{
    // VAR
    int i;
    char ch;

    // BEGIN
    Files* _this = _inst();
    i = 0;
    do
    {
        ch = x[i];
        _this->Write(R, ch);
        i++;
    } while( !( ch == 0x0 ) );
    // END
}

void Files::RestoreList()
{
    ; // NOP
}

void Files::setFileSystemPath(const QString& path)
{
    QFileInfo info(path);
    if( info.isDir() )
        d_fileSystemPath = path;
    else
        d_fileSystemPath = info.filePath();
}

Files::Files()
{
}

Files::~Files()
{
	s_inst.release();
}

